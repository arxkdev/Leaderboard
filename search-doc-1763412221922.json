{"searchDocs":[{"title":"Logger","type":0,"sectionRef":"#","url":"/Leaderboard/api/Logger","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Logger","url":"/Leaderboard/api/Logger#types","content":" ","version":null,"tagName":"h2"},{"title":"Object​","type":1,"pageTitle":"Logger","url":"/Leaderboard/api/Logger#Object","content":"&lt;/&gt; interface Object { __index: Object new: ( moduleName: string, debugEnabled: boolean ) → Logger Log: ( self: Logger, logLevel: number, message: string ) → () Destroy: (self: Logger) → () }   ","version":null,"tagName":"h3"},{"title":"LoggerArguments​","type":1,"pageTitle":"Logger","url":"/Leaderboard/api/Logger#LoggerArguments","content":"&lt;/&gt; interface LoggerArguments { _moduleName: string _debugEnabled: boolean }  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Logger","url":"/Leaderboard/api/Logger#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Logger","url":"/Leaderboard/api/Logger#new","content":"&lt;/&gt; Logger.new( moduleName: string, debugEnabled: boolean ) → Logger ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Logger","url":"/Leaderboard/api/Logger##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Logger","url":"/Leaderboard/api/Logger#Logger","content":"type Logger = () → Logger  Constructs a new Logger.  ","version":null,"tagName":"h3"},{"title":"Log​","type":1,"pageTitle":"Logger","url":"/Leaderboard/api/Logger#Log","content":"&lt;/&gt; Logger:Log( logLevel: number, message: string ) → nil Logs a message to the console.  ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Logger","url":"/Leaderboard/api/Logger#Destroy","content":"&lt;/&gt; Logger:Destroy() → nil Destroys the Logger. ","version":null,"tagName":"h3"},{"title":"Board","type":0,"sectionRef":"#","url":"/Leaderboard/api/Board","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board#types","content":" ","version":null,"tagName":"h2"},{"title":"BoardArguments​","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board#BoardArguments","content":"&lt;/&gt; interface BoardArguments { _boardKey: string _storeUsing: string _store: (MemoryStoreSortedMap | OrderedDataStore | MemoryShard)? _threads: {thread} }   ","version":null,"tagName":"h3"},{"title":"Object​","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board#Object","content":"&lt;/&gt; interface Object { __index: Object Update: ( self: Board, userId: number, value: number | (number) → (number) ) → Promise.TypedPromise&lt;boolean&gt; Get: ( self: Board, amount: number, sortDirection: string ) → Promise.TypedPromise&lt;{TopData}&gt; Destroy: (self: Board) → () new: ( boardKey: string, leaderboardType: LeaderboardType, rollingExpiry: number?, debugMode: boolean? ) → Board }  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board#new","content":"&lt;/&gt; Board.new( boardKey: string, leaderboardType: LeaderboardType, rollingExpiry: number?, debugMode: boolean? ) → Board ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board#LeaderboardType","content":"type LeaderboardType = &quot;Hourly&quot; | &quot;Daily&quot; | &quot;Weekly&quot; | &quot;Monthly&quot; | &quot;Yearly&quot; | &quot;AllTime&quot; | &quot;Rolling&quot; | string  ","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board#Board","content":"type Board = () → Board  Creates a new board within the Leaderboard.  ","version":null,"tagName":"h3"},{"title":"Get​","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board#Get","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Board:Get( amount: number, sortDirection: string? ) → Promise.TypedPromise&lt;{TopData}&gt; ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board#TopData","content":"interface TopData { Rank: number UserId: number Value: number Username: string DisplayName: string }  Gets the top data for a specific board.  ","version":null,"tagName":"h3"},{"title":"Update​","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board#Update","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Board:Update( userId: number, value: number | (number) → (number) ) → boolean Updates the data for a specific board (either MemoryStore (Shards), or OrderedDataStore).  ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Board","url":"/Leaderboard/api/Board#Destroy","content":"&lt;/&gt; Board:Destroy() → () Destroys the board. ","version":null,"tagName":"h3"},{"title":"Classes","type":0,"sectionRef":"#","url":"/Leaderboard/docs/classes","content":"","keywords":"","version":"Next"},{"title":"Class: Leaderboard​","type":1,"pageTitle":"Classes","url":"/Leaderboard/docs/classes#class-leaderboard","content":" The leaderboard class is used to create a leaderboard object. This object is used to interact with the individual boards which are children of the leaderboard.  ","version":"Next","tagName":"h3"},{"title":"Class: Board​","type":1,"pageTitle":"Classes","url":"/Leaderboard/docs/classes#class-board","content":" The board class is used to create a board. This board could etiher be (Hourly, Daily, Weekly, Monthly, Yearly, or All Time). This class interacts with the MemoryShard class to store the data using the set and get methods.  ","version":"Next","tagName":"h3"},{"title":"Class: MemoryShard​","type":1,"pageTitle":"Classes","url":"/Leaderboard/docs/classes#class-memoryshard","content":" The memory shard class is used to store individual MemoryMaps for each board. This is a recommended way as per the MemoryStores page under the Best practices tab. If you want to understand how this process works, please refer to the Sharding section of the Features page. ","version":"Next","tagName":"h3"},{"title":"Features","type":0,"sectionRef":"#","url":"/Leaderboard/docs/features","content":"","keywords":"","version":"Next"},{"title":"Intro​","type":1,"pageTitle":"Features","url":"/Leaderboard/docs/features#intro","content":" The foundation of this library is built upon the best practices recommended by Roblox, as listed here:  ","version":"Next","tagName":"h3"},{"title":"Sharding​","type":1,"pageTitle":"Features","url":"/Leaderboard/docs/features#sharding","content":" https://en.wikipedia.org/wiki/Shard_(database_architecture)  Leaderboard uses a custom sharding solution for MemoryStoreService to reduce the risk of hitting the size limits for a single Memory Map. This is done by splitting the data into multiple Memory Maps, and then using a custom hashing algorithm to determine which Memory Map to use for a given key.  ","version":"Next","tagName":"h3"},{"title":"Exponential Backoff​","type":1,"pageTitle":"Features","url":"/Leaderboard/docs/features#exponential-backoff","content":" https://en.wikipedia.org/wiki/Exponential_backoff  Leaderboard uses an exponential backoff algorithm to reduce the risk of hitting rate limits. This is done by waiting a certain amount of time before retrying a request, and then increasing the wait time exponentially for each retry.  ","version":"Next","tagName":"h3"},{"title":"Other​","type":1,"pageTitle":"Features","url":"/Leaderboard/docs/features#other","content":" Abstract API for easy integration into your existing codebaseCustomizable leaderboard settingsLeaderboard types: Hourly, Daily, Weekly, Monthly, All-Time and YearlyA special Leaderboard type for Rolling Leaderboards which automatically reset at a given intervalFull type support ","version":"Next","tagName":"h3"},{"title":"MemoryShard","type":0,"sectionRef":"#","url":"/Leaderboard/api/MemoryShard","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard#types","content":" ","version":null,"tagName":"h2"},{"title":"MemoryShard​","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard#MemoryShard","content":"&lt;/&gt; type MemoryShard = () → MemoryShard   ","version":null,"tagName":"h3"},{"title":"MemoryShardArguments​","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard#MemoryShardArguments","content":"&lt;/&gt; interface MemoryShardArguments { _type: LeaderboardType _boardKey: string _fallbackExpiry: number _isRollingExpiry: boolean _shards: {MemoryStoreSortedMap } _shardCount: number _logger: Logger.Logger? }   ","version":null,"tagName":"h3"},{"title":"Object​","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard#Object","content":"&lt;/&gt; interface Object { __index: Object _getShardKey: ( self: MemoryShard, userId: number ) → (number) _getAsync: ( self: MemoryShard, key: string ) → any _setAsync: ( self: MemoryShard, key: string, value: any, expiry: number, sortKey: number ) → boolean _updateAsync: ( self: MemoryShard, key: string, transformer: (any) → (any), expiry: number ) → boolean Set: ( self: MemoryShard, userId: number, value: number | (number) → (number) ) → Promise.TypedPromise&lt;boolean&gt; Get: ( self: MemoryShard, amount: number, sortDirection: string ) → Promise.TypedPromise&lt;{TopData}&gt; Destroy: (self: MemoryShard) → () new: ( leaderboardType: LeaderboardType, boardKey: string, shardCount: number, rollingExpiry: number?, debugMode: boolean? ) → MemoryShard }  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard#new","content":"&lt;/&gt; MemoryShard.new( leaderboardType: LeaderboardType, boardKey: string, shardCount: number, rollingExpiry: number?, debugMode: boolean? ) → () ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard#LeaderboardType","content":"type LeaderboardType = &quot;Hourly&quot; | &quot;Daily&quot; | &quot;Weekly&quot; | &quot;Monthly&quot; | &quot;Yearly&quot; | &quot;AllTime&quot; | string  Creates a new MemoryShard. This is not a viable solution anymore, as the limits to MemoryStoreService are too poor. See: https://devforum.roblox.com/t/introducing-memorystore-sortedmap-sortkey-beta/2673559/23  ","version":null,"tagName":"h3"},{"title":"Get​","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard#Get","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; MemoryShard:Get( topAmount: number, sortDirection: string ) → {TopData} ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard#TopData","content":"interface TopData { Rank: number UserId: number Value: number Username: string DisplayName: string }  Gets the top data from all the shards for this MemoryShard  ","version":null,"tagName":"h3"},{"title":"Set​","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard#Set","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; MemoryShard:Set( userId: number, value: number | (number) → (number) ) → boolean Updates the value for a specific user in a specific shard  ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"MemoryShard","url":"/Leaderboard/api/MemoryShard#Destroy","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; MemoryShard:Destroy() → () Destroys the MemoryShard ","version":null,"tagName":"h3"},{"title":"About","type":0,"sectionRef":"#","url":"/Leaderboard/docs/intro","content":"","keywords":"","version":"Next"},{"title":"What can I do with this?​","type":1,"pageTitle":"About","url":"/Leaderboard/docs/intro#what-can-i-do-with-this","content":" Create leaderboards for your Roblox experiencesPick from a variety of leaderboard types such as Hourly, Daily, Weekly, Monthly, All-Time and YearlyNot have to worry about rate limitsNot have to worry about messing with your PlayerData and setup a million hacky workarounds to store individual dated leaderboardsCustomize your leaderboard settings to your likingUse automation to automatically update your leaderboardsEasily integrate into your existing codebase with the abstract API  ","version":"Next","tagName":"h3"},{"title":"Why should I use this?​","type":1,"pageTitle":"About","url":"/Leaderboard/docs/intro#why-should-i-use-this","content":" Roblox developers often face challenges when implementing global leaderboards, particularly when dealing with various time periods. This library provides a streamlined solution, enabling you to create global leaderboards with just a few lines of code. Leaderboard supports different time periods, including All-Time, Monthly, Weekly, and Daily leaderboards. Additionally, it provides flexibility with a custom rolling time, allowing you to choose how long the leaderboard should display.  ","version":"Next","tagName":"h3"},{"title":"Why not OrderedDataStore?​","type":1,"pageTitle":"About","url":"/Leaderboard/docs/intro#why-not-ordereddatastore","content":" You should not be using ODS for non persistent data. It should be persistent data. For years there was a workaround to allow people to create Daily/Weekly/Monthly boards with ODS, a very hacky workaround, but now we have MemoryStoreService which is a much better solution for non persistent data. ","version":"Next","tagName":"h3"},{"title":"Leaderboard","type":0,"sectionRef":"#","url":"/Leaderboard/api/Leaderboard","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#types","content":" ","version":null,"tagName":"h2"},{"title":"Leaderboard​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#Leaderboard","content":"&lt;/&gt; type Leaderboard = () → Leaderboard   ","version":null,"tagName":"h3"},{"title":"LeaderboardType​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#LeaderboardType","content":"&lt;/&gt; type LeaderboardType = &quot;Hourly&quot; | &quot;Daily&quot; | &quot;Weekly&quot; | &quot;Monthly&quot; | &quot;Yearly&quot; | &quot;AllTime&quot; | string;   ","version":null,"tagName":"h3"},{"title":"LeaderboardArguments​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#LeaderboardArguments","content":"&lt;/&gt; interface LeaderboardArguments { Updated: Signal&lt;{AllTopData}&gt; BoardUpdated: Signal&lt;{ Type: LeaderboardType, Data: {TopData} }&gt; _serviceKey: string _types: LeaderboardTypeArgument _boards: {[LeaderboardType]: Board} _valueQueue: ValueQueueType _isSaving: boolean _lastSaved: number _isFetching: boolean _lastFetch: number _threads: {thread} _connections: {RBXScriptConnection } _logger: Logger.Logger? }   ","version":null,"tagName":"h3"},{"title":"Examples","type":0,"sectionRef":"#","url":"/Leaderboard/docs/examples","content":"","keywords":"","version":"Next"},{"title":"Automated Example:​","type":1,"pageTitle":"Examples","url":"/Leaderboard/docs/examples#automated-example","content":" local Leaderboard = require(game:GetService(&quot;ReplicatedStorage&quot;).Leaderboard); local Key = 1; -- The key for the leaderboard (change to reset) local LeaderboardTypes = { -- You must provide keys for the individual boards [&quot;Hourly&quot;] = `Hourly-{Key}`, [&quot;Daily&quot;] = `Daily-{Key}`, [&quot;Weekly&quot;] = `Weekly-{Key}`, [&quot;Monthly&quot;] = `Monthly-{Key}`, [&quot;AllTime&quot;] = `AllTime-{Key}`, }; local MoneyLeaderboard = Leaderboard.new(LeaderboardTypes, { -- Settings Automation = true, Interval = 5, RecordCount = 100, -- You can also do {Daily = 50, Weekly = 50, Monthly = 50, AllTime = 100} }) local function FunctionToIncrementMoney(userId: number, amount: number) -- This is where you would give the user money, just add this line to increment the leaderboard aswell MoneyLeaderboard:IncrementValues(&quot;All&quot;, userId, amount); end MoneyLeaderboard.Updated:Connect(function(boards) -- This is where you would update the leaderboard GUI -- Returns us a table of all the boards that were updated for _, board in boards do print(`Updating board {board.Type} - with {#board.Data} items!`); end; end)   ","version":"Next","tagName":"h3"},{"title":"Non-Automated Example:​","type":1,"pageTitle":"Examples","url":"/Leaderboard/docs/examples#non-automated-example","content":" local Leaderboard = require(game:GetService(&quot;ReplicatedStorage&quot;).Leaderboard); local INTERVAL = 120; -- 2 minutes local RECORD_COUNT = 100; -- Amount of records to get per board local Key = 1; -- The key for the leaderboard (change to reset) local LeaderboardTypes = { -- You must provide keys for the individual boards [&quot;Hourly&quot;] = `Hourly-{Key}`, [&quot;Daily&quot;] = `Daily-{Key}`, [&quot;Weekly&quot;] = `Weekly-{Key}`, [&quot;Monthly&quot;] = `Monthly-{Key}`, [&quot;AllTime&quot;] = `AllTime-{Key}`, }; local MoneyLeaderboard = Leaderboard.new(LeaderboardTypes); local function FunctionToIncrementMoney(userId: number, amount: number) -- This is where you would give the user money, just add this line to increment the leaderboard aswell MoneyLeaderboard:IncrementValues(&quot;All&quot;, userId, amount); end local function UpdateLeaderboards() -- Add the value to the data for _, Player in Players:GetPlayers() do FunctionToIncrementMoney(Player.UserId, 100); end; -- Retrieve the data MoneyLeaderboard:GetRecords(&quot;All&quot;, RECORD_COUNT):andThen(function(data) -- This is where you would update the leaderboard GUI -- Returns us a table of all the boards that were updated for _, board in data do print(`Updating board {board.Type} - with {#board.Data} items!`); end; end); end task.spawn(function() while (true) do UpdateLeaderboards(); task.wait(INTERVAL); end; end)   ","version":"Next","tagName":"h3"},{"title":"Rolling Leaderboard Example:​","type":1,"pageTitle":"Examples","url":"/Leaderboard/docs/examples#rolling-leaderboard-example","content":" local Leaderboard = require(game:GetService(&quot;ReplicatedStorage&quot;).Leaderboard); local Key = 1; -- The key for the leaderboard (change to reset) local Leaderboards = { [&quot;AllTime&quot;] = `AllTime-{Key}`, [&quot;10MinutesRolling&quot;] = {60 * 10, `10MinutesRolling-{Key}`}, -- 10 minutes rolling leaderboard [&quot;15MinutesRolling&quot;] = {60 * 15, `15MinutesRolling-{Key}`}, -- 15 minutes rolling leaderboard [&quot;1MinuteRolling&quot;] = {60, `1MinuteRolling-{Key}`}, -- 1 minute rolling leaderboard }; local MoneyLeaderboard = Leaderboard.new(Leaderboards, { Automation = true, Interval = 15, RecordCount = 100, -- You can also do {Daily = 50, Weekly = 50, Monthly = 50, AllTime = 100} }); local function IncrementMoneyTest() -- Test userIds local FakeId1, FakeId2 = 100, 101; MoneyLeaderboard:IncrementValues(Leaderboards, FakeId1, 100); MoneyLeaderboard:IncrementValues(Leaderboards, FakeId2, 100); end IncrementMoneyTest(); MoneyLeaderboard.Updated:Connect(function(boards) -- Returns us a table of all the boards that were updated for _, board in boards do print(`Updating board {board.Type} - with {#board.Data} items!`); end; end);  ","version":"Next","tagName":"h3"},{"title":"OperationType​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#OperationType","content":"&lt;/&gt; type OperationType = &quot;Set&quot; | &quot;Increment&quot; The type of operation to perform on the leaderboard value. &quot;Set&quot;: Sets the value to the specified amount or result of the transform function &quot;Increment&quot;: Adds the specified amount or result of the transform function to the current value  ","version":null,"tagName":"h3"},{"title":"Board​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#Board","content":"&lt;/&gt; interface Board { GetRecords: ( self: Board, amount: number, sortDirection: string ) → Promise.TypedPromise&lt;{TopData}&gt; Update: ( self: Board, userId: number, value: number | (number) → (number) ) → boolean Destroy: (self: Board) → () }   ","version":null,"tagName":"h3"},{"title":"Object​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#Object","content":"&lt;/&gt; interface Object { IncrementValues: ( self: Leaderboard, boardTypes: {LeaderboardType} | string, userId: number, amount: number ) → () SetValues: ( self: Leaderboard, boardTypes: {LeaderboardType} | string, userId: number, value: number | (number) → (number) ) → () UpdateStoreValues: ( self: Leaderboard, boardTypes: {LeaderboardType} | string, userId: number, value: number | (number) → (number) ) → () GetRecords: ( self: Leaderboard, boardTypes: {LeaderboardType} | string, optionalRange: {[LeaderboardType | string]: number} | number, sortDirection: string ) → Promise.TypedPromise&lt;{AllTopData}&gt; SaveValues: (self: Leaderboard) → Promise.TypedPromise&lt;nil&gt; Destroy: (self: Leaderboard) → () new: ( leaderboardTypes: {LeaderboardType}, automationSettings: AutomationSettings?, debugMode: boolean? ) → Leaderboard }  ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#properties","content":" ","version":null,"tagName":"h2"},{"title":"Updated​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#Updated","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Leaderboard.Updated: Signal&lt;{AllTopData}&gt; Fired when the leaderboard is updated.  ","version":null,"tagName":"h3"},{"title":"BoardUpdated​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#BoardUpdated","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Leaderboard.BoardUpdated: Signal&lt;{ Type: LeaderboardType, Data: {TopData} }&gt; Fired when a specific board is updated. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#new","content":"&lt;/&gt; Leaderboard.new( leaderboardTypes: LeaderboardTypeArgument, automationSettings: AutomationSettings?, debugMode: boolean? ) → Leaderboard ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#LeaderboardTypeArgument","content":"type LeaderboardTypeArgument = {[LeaderboardType]: any}  ","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#AutomationSettings","content":"interface AutomationSettings { Automation: boolean? Interval: number? RecordCount: number | {[string]: number}? }  Constructs a new leaderboard.  ","version":null,"tagName":"h3"},{"title":"SaveValues​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#SaveValues","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Leaderboard:SaveValues() → () Updates the actual store value(s) (should only be used every 90-120 seconds)  ","version":null,"tagName":"h3"},{"title":"GetRecords​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#GetRecords","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Leaderboard:GetRecords( boardTypes: {LeaderboardType} | &quot;All&quot;, optionalRange: {[string]: number} | number, sortDirection: string ) → Promise&lt;{AllTopData}&gt; ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#TopData","content":"interface TopData { Rank: number UserId: number Value: number Username: string DisplayName: string }  ","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#AllTopData","content":"interface AllTopData { Type: LeaderboardType Data: {TopData} }  Gets the data for all the top boards (should only be used every 90-120 seconds)  ","version":null,"tagName":"h3"},{"title":"IncrementValues​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#IncrementValues","content":"&lt;/&gt; Leaderboard:IncrementValues( boardTypes: {LeaderboardType} | &quot;All&quot;, userId: number, amount: number ) → () Increments the queued value(s) Increments the queued value(s)  ","version":null,"tagName":"h3"},{"title":"SetValues​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#SetValues","content":"&lt;/&gt; Leaderboard:SetValues( boardTypes: {LeaderboardType} | &quot;All&quot;, userId: number, value: number | (number) → (number) ) → () Updates the queued value(s) Updates the queued value(s)  ","version":null,"tagName":"h3"},{"title":"UpdateStoreValues​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#UpdateStoreValues","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Leaderboard:UpdateStoreValues( boardTypes: {LeaderboardType} | &quot;All&quot;, userId: number, value: number | (number) → (number) ) → () Updates the actual store value(s) (should only be used every 90-120 seconds) Updates the actual store value(s) (should only be used every 90-120 seconds)  ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Leaderboard","url":"/Leaderboard/api/Leaderboard#Destroy","content":"&lt;/&gt; Leaderboard:Destroy() → () Destroys the leaderboard ","version":null,"tagName":"h3"}],"options":{"id":"default"}}