"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[267],{8785:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>n});const a=JSON.parse('{"id":"classes","title":"Classes","description":"Heres a list of all the classes in the library and how they are used within the library.","source":"@site/docs/classes.md","sourceDirName":".","slug":"/classes","permalink":"/docs/classes","draft":false,"unlisted":false,"editUrl":"https://github.com/arxkdev/Leaderboard/edit/main/docs/classes.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"defaultSidebar","previous":{"title":"Examples","permalink":"/docs/examples"}}');var t=r(4848),d=r(8453);const o={sidebar_position:4},c="Classes",i={},n=[{value:"<b>Class</b>: <code>Leaderboard</code>",id:"class-leaderboard",level:3},{value:"<b>Class</b>: <code>Board</code>",id:"class-board",level:3},{value:"<b>Class</b>: <code>MemoryShard</code>",id:"class-memoryshard",level:3}];function l(e){const s={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",p:"p",...(0,d.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"classes",children:"Classes"})}),"\n",(0,t.jsx)(s.p,{children:"Heres a list of all the classes in the library and how they are used within the library."}),"\n",(0,t.jsxs)(s.h3,{id:"class-leaderboard",children:[(0,t.jsx)("b",{children:"Class"}),": ",(0,t.jsx)(s.code,{children:"Leaderboard"})]}),"\n",(0,t.jsx)(s.p,{children:"The leaderboard class is used to create a leaderboard object. This object is used to interact with the individual boards which are children of the leaderboard."}),"\n",(0,t.jsxs)(s.h3,{id:"class-board",children:[(0,t.jsx)("b",{children:"Class"}),": ",(0,t.jsx)(s.code,{children:"Board"})]}),"\n",(0,t.jsxs)(s.p,{children:["The board class is used to create a board. This board could etiher be (Hourly, Daily, Weekly, Monthly, Yearly, or All Time). This class interacts with the MemoryShard class to store the data using the ",(0,t.jsx)(s.code,{children:"set"})," and ",(0,t.jsx)(s.code,{children:"get"})," methods."]}),"\n",(0,t.jsxs)(s.h3,{id:"class-memoryshard",children:[(0,t.jsx)("b",{children:"Class"}),": ",(0,t.jsx)(s.code,{children:"MemoryShard"})]}),"\n",(0,t.jsxs)(s.p,{children:["The memory shard class is used to store individual MemoryMaps for each board. This is a recommended way as per the ",(0,t.jsx)(s.a,{href:"https://create.roblox.com/docs/cloud-services/memory-stores",children:"MemoryStores"})," page under the ",(0,t.jsx)(s.code,{children:"Best practices"})," tab. If you want to understand how this process works, please refer to the ",(0,t.jsx)(s.a,{href:"/docs/features#sharding",children:"Sharding"})," section of the Features page."]})]})}function h(e={}){const{wrapper:s}={...(0,d.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,s,r)=>{r.d(s,{R:()=>o,x:()=>c});var a=r(6540);const t={},d=a.createContext(t);function o(e){const s=a.useContext(d);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),a.createElement(d.Provider,{value:s},e.children)}}}]);