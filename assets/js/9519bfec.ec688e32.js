"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[696],{24917:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new MemoryShard. This is not a viable solution anymore, as the limits to MemoryStoreService are too poor.\\nSee: https://devforum.roblox.com/t/introducing-memorystore-sortedmap-sortkey-beta/2673559/23","params":[{"name":"leaderboardType","desc":"","lua_type":"LeaderboardType"},{"name":"serviceKey","desc":"","lua_type":"string"},{"name":"shardCount","desc":"","lua_type":"number"},{"name":"rollingExpiry","desc":"","lua_type":"number?"},{"name":"debugMode","desc":"","lua_type":"boolean?"}],"returns":[],"function_type":"static","source":{"line":109,"path":"src/Leaderboard/Board/MemoryShard.luau"}},{"name":"_getExpiry","desc":"Gets the expiry for a specific leaderboard type and key","params":[],"returns":[{"desc":"","lua_type":"number | nil"}],"function_type":"method","private":true,"source":{"line":133,"path":"src/Leaderboard/Board/MemoryShard.luau"}},{"name":"_getShardKey","desc":"Gets the Shard Key using prefixing and modulo","params":[{"name":"userId","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"number"}],"function_type":"method","private":true,"source":{"line":189,"path":"src/Leaderboard/Board/MemoryShard.luau"}},{"name":"_getAsync","desc":"Gets the value for a specific key from a specific shard","params":[{"name":"userId","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Promise.TypedPromise<{TopData}>"}],"function_type":"method","private":true,"source":{"line":209,"path":"src/Leaderboard/Board/MemoryShard.luau"}},{"name":"_setAsync","desc":"Destroys all the shards for this MemoryShard","params":[{"name":"userId","desc":"","lua_type":"string"},{"name":"value","desc":"","lua_type":"any"},{"name":"expiry","desc":"","lua_type":"number"},{"name":"sortKey","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","private":true,"source":{"line":227,"path":"src/Leaderboard/Board/MemoryShard.luau"}},{"name":"_updateAsync","desc":"Updates the value for a specific key from a specific shard","params":[{"name":"userId","desc":"","lua_type":"string"},{"name":"transformer","desc":"","lua_type":"(any) -> (any)"},{"name":"expiry","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","private":true,"source":{"line":244,"path":"src/Leaderboard/Board/MemoryShard.luau"}},{"name":"Get","desc":"Gets the top data from all the shards for this MemoryShard","params":[{"name":"topAmount","desc":"","lua_type":"number"},{"name":"sortDirection","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"{TopData}"}],"function_type":"method","yields":true,"source":{"line":261,"path":"src/Leaderboard/Board/MemoryShard.luau"}},{"name":"Set","desc":"Updates the value for a specific user in a specific shard","params":[{"name":"userId","desc":"","lua_type":"number"},{"name":"value","desc":"","lua_type":"number | (number) -> (number)"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","yields":true,"source":{"line":341,"path":"src/Leaderboard/Board/MemoryShard.luau"}},{"name":"Destroy","desc":"Destroys the MemoryShard","params":[],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","yields":true,"source":{"line":400,"path":"src/Leaderboard/Board/MemoryShard.luau"}}],"properties":[],"types":[{"name":"LeaderboardType","desc":"","lua_type":"\\"Hourly\\" | \\"Daily\\" | \\"Weekly\\" | \\"Monthly\\" | \\"Yearly\\" | \\"AllTime\\" | string","source":{"line":21,"path":"src/Leaderboard/Board/MemoryShard.luau"}},{"name":"MemoryShard","desc":"","lua_type":"() -> MemoryShard","source":{"line":27,"path":"src/Leaderboard/Board/MemoryShard.luau"}},{"name":"MemoryShardArguments","desc":"","fields":[{"name":"_type","lua_type":"LeaderboardType","desc":""},{"name":"_fallbackExpiry","lua_type":"number","desc":""},{"name":"_isRollingExpiry","lua_type":"boolean","desc":""},{"name":"_shards","lua_type":"{MemoryStoreSortedMap}","desc":""},{"name":"_shardCount","lua_type":"number","desc":""},{"name":"_logger","lua_type":"Logger.Logger?","desc":""}],"source":{"line":39,"path":"src/Leaderboard/Board/MemoryShard.luau"}},{"name":"TopData","desc":"","fields":[{"name":"Rank","lua_type":"number","desc":""},{"name":"UserId","lua_type":"number","desc":""},{"name":"Value","lua_type":"number","desc":""},{"name":"Username","lua_type":"string","desc":""},{"name":"DisplayName","lua_type":"string","desc":""}],"source":{"line":57,"path":"src/Leaderboard/Board/MemoryShard.luau"}},{"name":"Object","desc":"","fields":[{"name":"__index","lua_type":"Object","desc":""},{"name":"_getShardKey","lua_type":"(self: MemoryShard, userId: number) -> (number)","desc":""},{"name":"_getAsync","lua_type":"(self: MemoryShard, key: string) -> any","desc":""},{"name":"_setAsync","lua_type":"(self: MemoryShard, key: string, value: any, expiry: number, sortKey: number) -> boolean","desc":""},{"name":"_updateAsync","lua_type":"(self: MemoryShard, key: string, transformer: (any) -> (any), expiry: number) -> boolean","desc":""},{"name":"Set","lua_type":"(self: MemoryShard, userId: number, value: number | (number) -> (number)) -> Promise.TypedPromise<boolean>","desc":""},{"name":"Get","lua_type":"(self: MemoryShard, amount: number, sortDirection: string) -> Promise.TypedPromise<{TopData}>","desc":""},{"name":"Destroy","lua_type":"(self: MemoryShard) -> ()","desc":""},{"name":"new","lua_type":"(leaderboardType: LeaderboardType, serviceKey: string, shardCount: number, rollingExpiry: number?, debugMode: boolean?) -> MemoryShard","desc":""}],"source":{"line":78,"path":"src/Leaderboard/Board/MemoryShard.luau"}}],"name":"MemoryShard","desc":"A memory shard is a way to split up the leaderboard into multiple shards, each shard is a MemoryStoreSortedMap","source":{"line":96,"path":"src/Leaderboard/Board/MemoryShard.luau"}}')}}]);