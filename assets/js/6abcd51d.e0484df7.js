"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[267],{8785:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>n});const a=JSON.parse('{"id":"classes","title":"Classes","description":"Heres a list of all the classes in the library and how they are used within the library.","source":"@site/docs/classes.md","sourceDirName":".","slug":"/classes","permalink":"/Leaderboard/docs/classes","draft":false,"unlisted":false,"editUrl":"https://github.com/arxkdev/Leaderboard/edit/main/docs/classes.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"defaultSidebar","previous":{"title":"Examples","permalink":"/Leaderboard/docs/examples"}}');var d=r(4848),o=r(8453);const t={sidebar_position:4},c="Classes",i={},n=[{value:"<b>Class</b>: <code>Leaderboard</code>",id:"class-leaderboard",level:3},{value:"<b>Class</b>: <code>Board</code>",id:"class-board",level:3},{value:"<b>Class</b>: <code>MemoryShard</code>",id:"class-memoryshard",level:3}];function l(e){const s={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",p:"p",...(0,o.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(s.header,{children:(0,d.jsx)(s.h1,{id:"classes",children:"Classes"})}),"\n",(0,d.jsx)(s.p,{children:"Heres a list of all the classes in the library and how they are used within the library."}),"\n",(0,d.jsxs)(s.h3,{id:"class-leaderboard",children:[(0,d.jsx)("b",{children:"Class"}),": ",(0,d.jsx)(s.code,{children:"Leaderboard"})]}),"\n",(0,d.jsx)(s.p,{children:"The leaderboard class is used to create a leaderboard object. This object is used to interact with the individual boards which are children of the leaderboard."}),"\n",(0,d.jsxs)(s.h3,{id:"class-board",children:[(0,d.jsx)("b",{children:"Class"}),": ",(0,d.jsx)(s.code,{children:"Board"})]}),"\n",(0,d.jsxs)(s.p,{children:["The board class is used to create a board. This board could etiher be (Hourly, Daily, Weekly, Monthly, Yearly, or All Time). This class interacts with the MemoryShard class to store the data using the ",(0,d.jsx)(s.code,{children:"set"})," and ",(0,d.jsx)(s.code,{children:"get"})," methods."]}),"\n",(0,d.jsxs)(s.h3,{id:"class-memoryshard",children:[(0,d.jsx)("b",{children:"Class"}),": ",(0,d.jsx)(s.code,{children:"MemoryShard"})]}),"\n",(0,d.jsxs)(s.p,{children:["The memory shard class is used to store individual MemoryMaps for each board. This is a recommended way as per the ",(0,d.jsx)(s.a,{href:"https://create.roblox.com/docs/cloud-services/memory-stores",children:"MemoryStores"})," page under the ",(0,d.jsx)(s.code,{children:"Best practices"})," tab. If you want to understand how this process works, please refer to the ",(0,d.jsx)(s.a,{href:"/Leaderboard/docs/features#sharding",children:"Sharding"})," section of the Features page."]})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,d.jsx)(s,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}},8453:(e,s,r)=>{r.d(s,{R:()=>t,x:()=>c});var a=r(6540);const d={},o=a.createContext(d);function t(e){const s=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:t(e.components),a.createElement(o.Provider,{value:s},e.children)}}}]);